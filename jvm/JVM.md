# JVM

跨平台：

CPU位数:32位，64位

汇编语言不同等等

## 自动内存管理

对于C/C++开发人员来说在内存管理领域他们既是拥有最高权力的"皇帝"，又是从事最基础工作的劳动人民--既拥有每一个对象的所有权，又担负着每一个对象生命从开始到终结的维护责任

对于JAVA程序员来说在虚拟机自动内存管理机的帮助下，不再需要为每一个new操作去写配对的delete/free代码，不容易出现内存泄漏和内存溢出问题，看起来由虚拟机管理很美好但是一旦出现内存泄漏和溢出方面的问题如果不了解虚拟机时怎么使用内存，那排查错误修正问题将会称为一项异常艰难的工作



### 运行时数据区域:

**JAVA虚拟机在执行JAVA程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域由各自的用途以及创建和销毁的时间，有的区域随着虚拟机进程的启动而一直存在，有些区域则是依赖用户线程的启动和结束而建立和销毁。**

![image-20201211173243771](C:\Users\Administrator\Desktop\SpringBoot\picture\bed\image-20201211173243771.png)

![image-20201211173255813](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20201211173255813.png)

### 程序计数器

**程序计数器是一块较小的内存空间，它可以看作是当前线程所执行的字节码的信号指示器。**

**在JAVA虚拟机的概念模型里字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，它是程序控制流的指示器**。分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成

**由于JAVA虚拟机的多线程是通过线程轮流切换，分配处理器执行时间的方式来实现的**，在任何一个确定的时刻一个内核都只会执行一条线程中的指令。**因此为了线程切换后能恢复到正确的执行位置每个线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响独立存储，我们称这类内存区域为线程私有的内存**

如果线程正在执行的一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址，如果正在执行的是本地(Native)方法那么这个计数器值应该为空(Undefined)

- **程序计数器是一块很小的内存空间，它是当前线程的字节码指示器**
- **字节码解释器就是通过改变计数器值来选取下一条需要执行的字节码指令**(并非选择下一条使用哪个线程，而是选择该线程下一条执行哪条程序)
- **为了线程切换之后能恢复到正确的执行位置，每个线程都需要一个独立的程序计数器，各线程之间计数器互不影响独立存储**

### JAVA虚拟机栈

JAVA虚拟机栈与程序计数器一样也是线程私有的，它的生命周期与线程相同。

**虚拟机栈描述的是JAVA方法执行的线程内存模型，每个方法被执行的时候JAVA虚拟机都会同步创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息*****每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程**

**大部分情况下虚拟机栈只是指虚拟机栈中局部变量表**，局部变量表存放了编译期可知的各种JAVA虚拟机基本数据类型(int\boolean\char......)，对象引用(指T t=new T()的t)盒returnAddress类型



**这些数据类型在局部变量表中的存储空间以局部变量槽(Slot)来表示，其中64位长度的long盒double类型的数据会占用两个变量槽，其余数据类型只占用一个**。

**当进入一个方法是这个方法需要在栈帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的槽的数量。**

**虚拟机栈这个内存区域规定了两类异常状况:如果线程请求的栈深度大于虚拟机所允许的深度则抛出StackOverflowError异常，如果JAVA虚拟机栈容量可以动态扩展当栈扩展时不发申请到足够的内存会抛出OutOfMemoryError异常(OOM)，HotSpot不能进行动态扩展虚拟机栈容量但是只要线程申请栈空间失败仍旧会出现OOM异常**

### 本地方法栈

**本地方法栈与虚拟机栈所发挥的作用是相似的，区别只是虚拟机栈为虚拟机执行Java方法(按字节码执行),而本地方法栈则是为虚拟机使用到的本地方法服务(native修饰的)****，其余特性相同**，也会在运行本地方法的时候创建一个栈帧，存储局部变量、操作数栈、动态链接、方法出口类型，在运行之前编译时就以确定这个栈帧所需要分配多大的空间运行期间不会改变局部变量表的槽的数量，同样只有64位的long和double会占用两个变量槽，其他数据类型都只占用一个变量操，在线程访问深度大于虚拟机所允许的 深度的时候也会抛出StackOverflowError异常，在动态扩展失败(HotSpot不能动态扩展)或申请栈空间失败时也会出现OOM异常

### Java堆

对于Java应用程序来说,Java堆是虚拟机所管理的内存中最大的一块。**Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建，此内存区域的唯一目的就是存放对象实例(T t=new T();这里的对象实例是指new T(),t是对象引用)。** **Java里几乎所有的对象实例都在这里分配内存，所有的对象实例以及数组都应当在堆上分配**。

Java堆是垃圾收集器管理的内存区域，因此一些资料中他也被成为GC堆。从回收内存的角度看，由于现代垃圾收集器大部分都是基于分代收集理论设计的，**所以Java堆中经常会出现"新生代"、"老年代"、"永久代"、"Eden空间"、"From Survivor空间"、"To Survivor空间"等名词，这些区域划分仅仅是一部分垃圾收集器的共同特性或者说设计风格，而不是某个Java虚拟机具体实现的固有内存布局**.HotSpot里面也出现了不采用分代设计的新垃圾收集器

**如果从分配内存的角度看，所有线程共享的Java堆中可以划分出多个线程私有的分配缓冲区，以提升对象分配时的效率，不过无论从什么角度无论如何划分都不会改变Java堆中存储内容的共性，无论是哪个区域存储的都只能是对象的实例，将Java堆细分的目的只是为了更好的回收内存或者更快的分配内存**

**Java堆可以处于物理上不连续的内存空间中，但逻辑上他应该被视为连续的**，类似于磁盘空间存储文件，不要求每个文件都连续存放但对于大对象(如数组对象)多数虚拟机实现出于简单存储高效的考虑很有可能会要求联系的内存空间

**Java堆既可以被是现成固定大小的，也可以是可扩展的，不过当前主流的Java虚拟机都是按照可扩展来实现的(通过参数-Xmx和-Xms设定)**。**如果在Java堆中没有内存完成实例分配并且堆也无法再扩展时 Java虚拟机将会抛出OOM异常**

- **Java堆是所有线程共享的一片内存区域，用于存放对象实例**
- Java堆可以划分出很多个线程私有的而分配缓冲区以提升对象分配时的效率，但是也只能存放对象的实例，将 Java堆细分的目的只是为了更好的回收内存或者更快的分配内存
- Java堆可以处于物理上不连续的内存空间中，但是逻辑上它应该被视为连续的
- Java堆可以被是现成固定大小的也可以时可扩展的，不过当前主流的Java虚拟机都是可扩展的，**如果再Java堆中没有内存完成实例分配并且堆也无法再扩展时Java虚拟机将会抛出OOM异常**

### 方法区

**方法区和Java堆一样是各个线程共享的内存区域，它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据**

**说到方法区不得不提一下"永久代"这个概念，本质上这两者并不是等价的，因为仅仅是当时的HotSpot虚拟机设计团队选择把收集器的分代设计扩展至方法区，或者说使用永久代来实现方法区而已**，这样使得HotSpot的垃圾收集器能够像管理Java堆一样管理这部分内存，省去专门为方法区编写内存管理代码的工作。但是对于其他虚拟机时不存在永久代的概念的。原则上如何实现方法区属于虚拟机实现细节不要求统一，但是使用永久代来实现方法区的决定并不是一个好主意，这种设计导致了Java应用更容易遇到内存溢出的问题，而且有极少数方法会因永久代的原因而导致不同 虚拟机下有不同的表现。**在JDK8完全废弃了永久代的概念，改用在本地内存中实现的元空间来代替，将永久代还剩余的内容全部移到元空间中**

**Java方法区和Java堆一样不需要连续的内存和可以选择固定大小或者可扩展外，甚至还可以选择不实现垃圾收集**。**相对而言垃圾收集行为在这个区域的确是比较少出现，但并非数据进入了方法区就如同永久代的名字一样永久存在了。这区域的内存回收目标主要是针对常量池的回收和对类型的卸载**，一般来说这个区域的回收效果比较难令人满意，但是这部分区域的回收又是必要的

- 方法区和Java堆相同是所有线程共享的一块区域，它主要是存储已经被虚拟机加载的类型信息、常量、静态变量以及编译后的缓存
- 方法区和永久代是两个概念，只是因为在设计的 时候使用了永久代来实现方法区的分代设计，两者不能混为一谈
- 方法区的垃圾回收主要是针对常量池的回收和对类型的卸载
- jdk8以后将永久代得所有内容全部移动到元空间中了

### 运行时常量池

**运行时常量池是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外还有一项信息是常量池表，用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中**

**相较于Class文件常量池，运行时常量池更具动态性，在运行期间也可以将新的变量放入 常量池中，而不是一定要在编译时确定的常量才能放入**

#### 字符串常量池

在JDK6之前得版本中字符串常量池是放在方法区中

在JDK7版本中字符串常量池被移动到了堆中。

字符串常量池是什么？

- **在HotSpotVM里实现得String pool功能是一个StringTable类是一个Hash表默认值大小长度是1009**；这个String Table在每个HotSpotVM得实例只有一份，被所有得类共享**，字符串常量由一个一个字符组成放在了StringTable上**

- 在JDK6中StringTable得长度是固定得长度就是1009，因此如果放入StringPool得String非常多就会造成hash冲突导致链表过长，当调用String.intern()时会需要到链表上一个一个找从而导致性能大幅度下讲

- 在JDK7中String Table得长度可以通过参数指定

  ```
  -XX:StringYableSize=66666
  ```

  

字符串常量池里放的是什么?431

- 在JDK6及之前得版本中StringPool里面放的都是字符串常量

- 在JDK7中由于String#intern()发生了改变因此**StringPool中也可以存放放于堆内得字符串对象得引用**，**需要说明得是字符串常量池中得字符串只存在一份**

  ```
  String s1="hello,world";
  String s2="hello,world";
  ```

  即执行完第一行代码之后常量池中已存在"hello,world"那么s2不会再常量池中申请新的空间，而是直接把已存在得字符串内存地址返回给s2

#### class常量池

- 我们写的每一个Java类被编译之后就会形成一份class文件；**class文件中**除了包含类得版本、字段、方法、接口等描述信息外，**还有一项信息就是常量池**，**用于存放编译器生成得各种字面量和符号引用**
- **每个class文件都有一个class常量池**

什么是字面量和符号引用?

- **字面量包括:1.文本字符串2.八种基本类型得值3.被声明为final得常量等**
- **符号引用包括:1.类和方法得全限定名2.字段得名称和描述符3.方法得名称和描述符**

#### 运行时常量池

- 运行时常量池存在于内存中，也就是class常量池被加载到内存之后得版本，不同之处是:**它的字面量可以动态得添加，符号引用可以被解析为直接引用**
- 12M再执行某个类得时候必须经过加载、链接、初始化，而链接又包括验证、准备、解析三个阶段。而当类加载到内存中后，jvm就会将class常量池中得内容存放到运行时常量池中，**由此可知，运行时常量池也是每个类都有一个。**在**解析阶段，会把符号引用替换为直接引用，解析得过程会去查询字符串常量池，也就是我们上面所说得StringTable,以保证运行时常量池所引用得字符串与字符串常量池中是一致的**

### 直接内存

**直接内存并不是虚拟机运行时数据区的一部分，也不是JVM中定义的内存区域。但是这部分内存也频繁的被使用而且也可能导致OOM异常出现**。

在JDK1.4中新加入了**NIO类，引入了一种基于通道与缓冲区的I/O方式，它可以使Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作**。**这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据**

**显然本机直接内存的分配不会收到java堆大小的限制**，但是，既是内存肯定**还是会收到本机总内存大小以及处理器寻址空间的限制**，一般服务器管理员配置虚拟机参数时，**会根据实际内存区设置-Xmx等参数信息但是经常忽略掉直接内存，使得各个内存区域总和大于物理内存限制，从而导致动态扩展时出现OOM异常**

### 对象的创建

Java是一门面向对象的编程语言，Java程序运行过程中无时无刻都有对象被创建出来，**当JVM遇到一条字节码new指令时首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号应用代表的类是否已被加载、解析和初始化过，如果没有那必须先执行相应的类加载过程**

在类加载检测通过过后，接下来虚拟机将为新生对象分配内存，对象所需内存的大小在类加载完成后可确定，等同于把一块确定大小的内存快从Java堆中划分出来

对象创建在虚拟机中是非常频繁的行为**，即使仅仅修改一个指针所指向的位置在并发的情况下也不是线程安全的**，**可能出现正在给对象A分配内存指针还没来得即修改，对象B又同时使用了原来的指针来分配内存的情况**。有两种可选方案:一种是堆分配内存空间的动作进行同步处理--**实际上虚拟机是采用CAS配上失败重试的方式保证更新操作的原子性**，**另一种是**把内存分配的动作按照线程划分在不同的空间之中进行，即**每个线程在Java堆中先分配一小块内存成为本地线程分配缓冲**，哪个线程需要分配内存，就在哪个线程的本地缓冲区中分配，**只有本地缓冲区用完了分配新的缓冲区时才需要同步锁定**。虚拟机是否使用本地线程分配缓冲可以通过-XX:+/-UserTLAB参数来设定

**内存分配完成之后，虚拟机必须将分配到的内存空间(不包括对象头)都初始化**，如果使用了TLAB的话这一项工作也可以提前至T:AB分配时顺便进行，这部操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，使程序能访问到这些字段的数据类型所对应的初始值

接下来JVM还需要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息，这些信息存放在对象头中。根据虚拟机当前运行状态的不同，如是否启动偏向锁，对象头是有不同的设置方式。

然后需要调用对象的构造函数，这样一个真正可用的对象才算被完全被构造出来，最后需要将对象引用和对象联系起来(T t=new T())

- 首先去常量池中寻找是否有该类的符号引用，然后检查这个符号引用是否已经被加载、解析、初始化，如果没有那么必须进行加载、解析、初始化
- 其次在类检测通过之后会对该对象进行内存分配，这个对象所需要分配多大的内存是在类加载之后可确定的，相当于在Java堆中划分了一块大小确定的内存
- 内存分配完成之后JVM必须将该类分配到的内存空间(不包含对象头)进行初始化
- 然后JVM还需要对对象进行必要的设置，例如对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息，这些信息存放在对象头中
- 然后调用对象的构造函数这样一个真正可用的对象才算被完全构造出来
- 最后需要将对象引用和对象联系起来(T t=new T())

对象头MarkWord

![image-20201225181145614](C:\Users\Administrator\Desktop\SpringBoot\picture\bed\image-20201225181145614.png)

对象头的另一部分是类型指针，即对象指向它的类型元数据的指针，JVM通过这个指针来确定该对象是哪个类的实例

### 对象的访问定位

**Java程序会通过栈上的reference数据来操作堆上的具体对象,由于reference在JVM里面只是一个指向那个对象的引用并没有定义的这个引用应该通过什么方式去定位、访问到堆中对象的具体位置**，所以对象访问方式也是由虚拟机实现而定的，主流的访问方式主要有使用句柄和直接指针两种:

**如果使用句柄访问的话**，Java堆中将可能会**划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址**，而句柄中包含了对象实例数据与类型数据各自具体的地址信息

**如果使用直接指针方法的话**，Java堆中对象的内存布局就必须考虑如何放置访问类型数据的相关信息，**reference中存储的直接就是对象地址**，如果只是访问对象本身的话就不需要多一次间接访问的开销

两种对象的访问方式各有各的优势

- 使用句柄来访问的最大好处就是reference中存储的是稳定句柄地址，在对象被移动(垃圾收集时移动对象时非常普遍的行为)时只改变句柄中的实例数据指针而reference本身不需要被修改

  ![image-20201225190628946](C:\Users\Administrator\Desktop\SpringBoot\picture\bed\image-20201225190628946.png)

- **使用直接指针来访问最大的好处就是速度更快**，它节省了一次指针定位的时间开销，由于对象访问在Java中非常频繁，因此这类开销积少成多也是一项极为可观的执行成本，**就HotSpot而言它主要使用第二种方式进行对象访问**![image-20201225191204884](C:\Users\Administrator\Desktop\SpringBoot\picture\bed\image-20201225191204884.png)

## 垃圾收集器与内存分配策略

垃圾收集——GC

**什么是GC？GC就是垃圾回收，它的主要作用就是回收程序中不再使用的内存**

垃圾收集需要完成的三件事：

- 那些内存需要回收
- 什么时候回收
- 如何回收

经过半个世纪的发展今天的内存动态分配与内存回收技术已经相当成熟，一切看起来都进入了“自动化”时代，那么为什么我们还要去了解垃圾收集和内存分配?答案很简单:当需要排查各种内存溢出、内存泄漏问题时，当垃圾收集成为系统达到更高并发量的瓶颈时，我们就必须对自动化的技术实施必要的监控和调节

有关程序计数器、虚拟机栈、本地方法栈这3个区域随线程而生随线程而灭，**这几个区域的内存分配和回收都具备确定性，在这几个区域内就不需要过多考虑如何回收的问题，当方法结束或者线程结束时，内存自然就跟随着回收了**

而Java堆和方法区这两个区域有着很显著的不确定性:一个接口的多个实现雷需要的内存可能会不一样，一个方法所执行的不同条件分支所需要的内存也可能不一样，**只有处于运行期间我们才能知道程序究竟会创建哪些对象，创建多少个对象**，这部分内存的分配和回收是动态的，GC所关注的正式这部分内存该如何管理

### 对象已死？

在堆里面存放着Java世界中几乎所有的对象实例，**垃圾收集器在对堆进行回收前，第一件事就是要确定这些对象之中哪些还存活着，哪些已经死去**(死去即不可能再被任何途径使用的对象)

### 引用计数算法

很多教科书判断对象是否存活的算法是这样的:在对象中添加一个引用计数器，每当有一个地方引用它时，计数器就加一，当引用失效时计数器值就减一，任何时刻计数器为零的对象就是不可能再被使用的。**客观的说引用计数算法虽然占用了额外的内存来进行计数它的原理简单，判定效率也很高，但是在主流的Java虚拟机里面没有选用引用计数算法**。

引用计数算法有很多例外情况要考虑，必须要配合大量额外处理才能保证其正确的工作，譬如单纯的引用计数就很难解决对象直线相互循环引用的问题。

```
public class ReferenceCountingGC{
   public Object instance=null;
   private static final int _1MB=1024*1024;
   private byte[] bigSize=new byte[2*_1MB];
   public static void test(){
     ReferenceCountingGC objA=new ReferenceCountingGC();
     ReferenceCountingGC objB=new ReferenceCountingGC();
     objA.instance=objB;
     objB.instance=objA;
     objA=null;
     objB=null;
     //假设在这行发生GC，objA和objB能否被回收
     System.gc();
   }
}
从结果可以看出虚拟机并没有因为这两个对象互相引用就放弃回收他们，这也侧面说明了Java虚拟机并不是通过引用计数算法来判断对象是否存活的
```

### 可达性分析算法

**当前主流的Java虚拟机都是通过可达性分析算法来判定对象是否存活的。**

这个算法的基本思路就是通过一系列成为"GC Root"的根对象作为起始节点集，从这些结点开始，根据引用关系向下搜索，搜索过程所走过的路径成为"引用链",如果某个对象到GC Roots间没有任何引用链相连，或者说从GC Root到这个对象不可达时，则证明此对象时不能再被使用的

![image-20201230145101448](C:\Users\Administrator\Desktop\SpringBoot\picture\bed\image-20201230145101448.png)

在Java体系里面按固定可作为GC Roots的对象包括以下几种:

- 在虚拟机栈中引用的对象，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等
- 在方法区中类静态属性引用的对象，譬如Java类的引用类型静态变量
- 在方法区中常量引用的对象譬如字符串常量池里的引用
- 在本地方法栈中Native引用的对象
- 在Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象
- 所有被同步锁持有的对象
- 反映Java虚拟机内部情况的回调、本地代码缓存等

除了这些固定的GCRoots集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象临时性的加入，共同构成完整GCRoots集合

### 生存还是死亡?

**即使在可达性分析算法中判定为不可达的对象，也不是非死不可的**，这时候他们暂时还处于"缓刑"阶段，要阵阵宣告一个对象死亡至少要经历两次标记过程:如果对象在进行可达性分析后发**现没有与GC Roots相链接的引用链，那它将会被第一次标记**，**随后进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法，假如对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，那么虚拟机将这两种情况都视为"没有必要执行"**

如果这个对象被判定为确有必要执行finalize()方法(**对象覆盖了finalize()方法并且finalize()方法没有被虚拟机调用过**),那么该对象将会被放置在一个名为F-Queue的队列中，并且在稍后由一条由虚拟机自动建立的、低调度优先级的Finalize线程去执行他们的finalize()方法。**这里的执行是指虚拟机会触发这个方法开始运行，但并不承诺一定会等待它运行结束**。这样做的原因是，如果某个对象的finalize()方法执行缓慢或者更极端地发生了死循环，将很可能导致F-Queue队列中地其他对象永久处于等待，甚至导致整个内存回收子系统地崩溃**。finalize()方法是对象逃脱死亡命运地最后一次机会，稍后收集器将对F-Queue中地对象进行第二次小规模地标记，如果对象要在finalize()中成功拯救自己只需要重新与引用链上地任何一个对象建立关联即可**。但是任何一个对象地finalize()方法都只会被系统自动调用一次，如果对象面临下一次回收它的finalize()方法不会被再次执行，因此第二段代码地自救行动失败了

### 回收方法区

有些人认为方法区(如HotSpot虚拟机中地元空间或者永久代)是没有垃圾收集行为的，实际上确实有为实现方法区类型收集器的存在，但是方法区垃圾收集的"性价比"通常也是比较低的

**方法区的垃圾收集主要回收两部分:废弃的常量和不在使用的类型。** **回收废弃常量与回收Java堆中的对象非常类似**，举个常量池中字面量回收的例子，加入一个字符串"java"曾经进入常量池中，但是当前系统又没有任何一个字符串的指向的值是"java",换句话说，已经没有任何字符串对象引用常量池中的"java"常量，且虚拟机中也没有其他地方引用这个字面量。如果在这个时候发生GC，而且垃圾收集器判断确实有必要的话，这个"java"常量就会被系统清理出常量池。常量池中其他类(接口)、方法、字段的符号引用也与此类似

### 垃圾收集算法

**从如何判定对象消亡的角度出发，垃圾收集算法可以划分为"引用计数式垃圾收集"和"追踪式垃圾收集"。这两类也常被称作"直接垃圾收集"和"间接垃圾收集"，但是"引用计数式垃圾收集算法"在主流的Java虚拟机中均未设计。**

### 分代收集理论

当代商业虚拟机的垃圾收起大多数都遵循了分代收集的理论进行设计，分代收集名为理论实质上是一套符合大多数程序运行实际情况的经验法则，它建立在两个分代假说之上:

- 弱分代假说:绝大多数对象都是朝生夕灭
- 强分代假说:熬过越多次垃圾收集过程的对象就越难以消亡
- 跨分代假说:一个分代中可能有另一个分代的互相引用的对象,他们应该共存活共消亡

**两个分代假说共同奠定了多款常用的垃圾收集器的一致的设计原则:收集器应该将Java堆划分出不同的区域，然后将回收对象依据其年龄(年龄即对象熬过垃圾收集过程的次数)分配到不同的区域之中存储**。显而易见**如果一个区域中大多数对象都是朝生夕灭**难以熬过垃圾收集过程的话那么**把他们集中放在一起每次回收时只关注如何保留少量存活而不是去标记那些大量将要被回收的对象**，就能以较低的代价回收到大量的空间，**如果剩下的都是难以消亡的对象，那么把他们集中放一块虚拟机便可以使用较低的频率来回收这个区域**，这就同时兼顾了垃圾收集的时间开销和内存的空间有效利用

在Java堆划分出不同的区域之后，垃圾收集器才可以每次只回收其中某一个或者某些部分的区域——因而才有了"MinorGC""Major GC""Full GC"这样的回收类型的划分；也才能够针对不同的区域安排与里面存储对象存亡特征相匹配的垃圾收集算法

分代收集理论具体放到现在的商用Java虚拟机里**设计者一般至少会把Java堆划分为新生代和老年代两个区域**。**顾名思义在新生代中每次垃圾收集时都发现大批对象死去，而每次回收后存活的少量对象，将会逐步晋升到老年代中存放**

**对象之间还有跨代的现象**，加入要现在进行一次只局限于新生代区域内的收集，但新生代中的对象时完全有可能被老年代所引用的，为了找出该区域中的存活对象，不得不在固定的GC Roots之外再额外遍历整个老年代中所有对象来确保可达性分析结果的正确性，反过来也一样，为了解决这个问题就需要堆分代收集理论添加第三条经验法则

**跨代引用假说**,跨代引用相对于通带引用来说仅占极少数，这其实是可根据前两条假说逻辑推理得出的隐含推论:**存在互相引用关系的两个对象，是应该倾向于同时生存或者同时消亡**。举个例子如果某个新生代对象存在跨代引用，由于老年代对象难以消亡，该引用会使得新生代对象再收集时同样得以存活，进而再年龄增长之后晋升到老年代，这时跨代引用也随即消除了

**依据这条假说我们就不应再为了少量的跨代引用去扫描整个老年代，也不必浪费空间专门记录每一个对象是否存在以及存在跨代引用，只需要再新生代上建立一个全局的数据结构(该数据结构被称为记忆集)，这个结构把老年代划分为若干小块，标识出老年代的那一块内存会存在跨代引用，此后发生Minor GC时只有包含了跨代引用的小块内存里的对象才会被加入到GCRoots进行扫描**。虽然这种方法需要再对象改变引用关系时维护记录数据的正确性会增加一些运行时的开销，但比起收集时扫描整个老年代来说仍然时划算的

不同分类的名词:

- 新生代收集——MinorGC /Young GC指目标只是新生代的垃圾收集
- 老年代收集——MajorGC/Old GC指目标只是老年代的垃圾收集
- 混合收集——Mixed GC指目标是收集整个新生代以及部分老年代的垃圾收集
- 整堆收集——Full GC指收集整个Java堆和方法区的垃圾收集

### 标记-清除算法

最早出现也是最基础的垃圾收集算法是"标记-清除"算法，如它的名字一样**算法分为标记和清除两个阶段**，首先标记出所有需要回收的对象，再标记完成后统一回收掉所有被标记的对象，也可以反过来，标记存活的对象，统一回收所有未被标记的对象，标记过程就是对象是否属于垃圾的是判定过程。

之所以说它是最基础得收集算法，是因为后续得收集算法大多都是以标记-清除算法为基础，对其缺点进行改进而得到得。它的缺点有两个:**第一个是执行效率不稳定**，如果Java堆种包含大量对象，而且其中大部分是需要被回收得，这时必须进行大量标记和清除动作，**导致标记和清除两个过程得执行效率都随对象数量增长而降低**，第**二个是内存空间得碎片化问题**，标记、清除之后会产生大量不连续得内存碎片，**空间碎片太多可能会导致当以后再程序运行过程中需要分配较大对象时无法找到足够得连续空间而不得不提前触发另一次垃圾收集动作**

![image-20210108162151115](C:\Users\Administrator\Desktop\SpringBoot\picture\bed\image-20210108162151115.png)

### 标记-复制算法

**标记-复制算法常被简称为复制算法**。为了解决标记-清除算法面对大量可回收对象时执行效率低得问题，**它将可用内存按容量划分为大小相等的两块，每次只使用其中一块**，当这一块的内存使用完了就将还存活者的对象复制到另一块上面然后再把已经使用过的内存空间一次清理掉。**如果内存中多数对象都是存活的，这种算法将会产生大量的内存间复制的开销**，但对于多数对象都是可回收的情况，算法需要复制的就是占少数的存活对象，而且每次都是针对整个半区进行内存回收，分配内存时也就不用考虑有空间碎片的复杂情况，**实现简单，运行高效，不过缺陷也很明显，这种复制回收算法的代价是将可用内存缩小为了原来的一般，空间浪费太多了一点**

![image-20210108163024480](C:\Users\Administrator\Desktop\SpringBoot\picture\bed\image-20210108163024480.png)

现在的商用Java虚拟机大多都优先采用了这种收集算法去回收新生代，但是新生代种有98%熬不过第一轮收集。因此并不需要按照1:1的比例来划分新生代的内存空间

**现在HotSpot虚拟机采用了Appel式回收这种策略来设计新生代的内存布局**，**Appel式回收的具体做法式把新生代分为一块较大的Eden空间和两块较小的Survivor空间**，每次分配内存只使用Eden和其中一块Survivor,发生垃圾收集时将Eden和Survivor种仍然存活的对象一次性复制到另一块Survivor空间上，然后直接清理掉Eden和已用过的那块Survivor空间，**如果剩下的一块较小的Survivor空间不足以分配内存，那么会从老年代区域担保一部分内存用做暂时的存储内存，但是最终也会还给老年区**

### 标记-整理算法

标记-复制算法再对象存活率较高时就要进行较多的复制操作，效率将会降低。更关键的是，如果不想浪费50%的空间就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都是100%存活的极端情况，所以老年代一般不能直接选用这种算法。

**针对老年代对象的存亡特征提出了标记-整理算法**，**其中的标记过程仍然与标记-清除算法一样，但是后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内存**

![image-20210108165535040](C:\Users\Administrator\Desktop\SpringBoot\picture\bed\image-20210108165535040.png)

如果移动存活对象，尤其是在老年代这种每次回收都有大量对象存活区域，移动存活对象并更新所有引用这些对象的地方将会是一种极为负重的操作，而且这种对下昂移动操作必须全程暂停用户应用程序才能进行，但如果完全不考虑移动和整理存活对象的话，弥散于堆中的存活对象导致的空间碎片化问题就只能依赖更为复杂的内存分配器和内存访问其来解决

基于以上两点是否移动对象都存在弊端，移动则内存回收时会更复杂，不移动则内存分配时会更复杂。从垃圾收集的停顿时间来看，不移动对象停顿时间会更短甚至不需要停顿，**但是从整个程序的吞吐量来看，移动对象会更划算，即使不移动对象会使得收集器的效率提升一些，但因内存分配和访问相比垃圾收集 频率要高得多这部分得耗时增加总吞吐量是下降得**

